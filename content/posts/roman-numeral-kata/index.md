---
layout: post
title: "Commentary on 'Roman Numerals Kata with Commentary'"
description: "My approach to the Roman Numerals Kata"
date: 2014-01-12
categories: ["Worked Examples"]
---

先日、["Roman Numerals Kata with Commentary"](http://blog.coreyhaines.com/2012/12/roman-numerals-kata-with-commentary.html)という動画を見ました。
その中でCorey Haines氏は、[Arabic to Roman Numerals Kata](http://codingdojo.org/kata/RomanNumerals/)をTDDのアプローチでRubyで実装する方法を示しています。

*このビデオは私を強烈に苛立たせました。*

私はCorey Haines氏のプログラミングスキルを軽視しているわけではありません。多くの人がこのビデオを有用だと思っているようですが、私はただ苛立たしいと感じただけです。

この記事では、なぜ私がイライラしたのか、そしてこのような問題に対する私の選択肢を説明しようと思います。

## 要件はどこに?

> *”プログラミングを始める前に、自分のプログラムが何をするかの大まかなスケッチを書くプログラマーはほとんどいません。ほとんどのプログラマーは、コードを生成しないものは時間の無駄だと考えています。”*
>
> *Leslie Lamport, ["Why We Should Build Software Like We Build Houses"] (http://www.wired.com/opinion/2013/01/code-bugs-programming-why-we-need-specs/) *

標準的なTDDのやり方では、まず最初に失敗するケース (0処理) を実装し、それを動作させ、次に"1"を処理するテストケースを追加して、それを動作させます。

これこそが私が最初に苛立たせたことでした -- 要件を本当に理解せずにコードに飛び込むなんて。

[Programming Kata](http://en.wikipedia.org/wiki/Kata_ (programming) ) と呼ばれるのは、開発者としてのスキルを練習することが目的です。
しかし私にとって、コーディングスキルはソフトウェア開発者の一面にすぎず、常に最重要とは限りません。

大部分の開発者が実践すべきことがあるとすれば、それは顧客のニーズ (要件) に耳を傾け、理解することではないでしょうか。
コードを書くことだけではなく,価値を提供するというゴールを忘れてはなりません。

この場合、kataに [ページ](http://codingdojo.org/kata/RomanNumerals/) があるにもかかわらず、要件は幾分あいまいです。
私はこのことを、問題を掘り下げ、新しい学びを得る絶好の機会だと考えることにしました。

## ドメインエキスパートになる

実際、要件をできる限り深く掘り下げることには、重要な利点があると思います。

**楽しみ**。新しいドメインを本当に理解するのは楽しいです。私は新しいことを学ぶのが好きです--これが開発者としての特権の1つです。


私だけじゃありません。Dan North氏は ["accelerating agile"](http://vimeo.com/68215534) というプレゼンテーションの中で、ドメインの専門家たちと非常に密接に仕事をしたことの楽しさを語っています。
チームの成功の一因は、開発者がトレーダー自身と一緒にドメイン (トレーディング) を研究し、コミュニケーションが容易で混乱が最小限に抑えられたことです。

**優れた設計**。優れたソフトウェアを作成するには、モデル化しようとしている分野の合理的な専門家になる必要があります。
これはもちろん、ドメイン駆動設計の背後にあるテーマですが、アジャイルプロセスの重要な要素でもあります:あらゆる段階で開発者と密接に協力する "現場の顧客"です。

また、ほとんどの場合、要件を適切に理解することで、ソリューションを実装するための適切な*方法を見つけることができます。
深い洞察の欠如は、浅い反復では補うことが不可能です。
{{<footnote "*">}}
もちろん、 "正しい"方法はありませんが、間違った方法はたくさんあります。私が言いたいのは恐ろしく複雑でメンテナンス不可能なものにしない方法という意味です。
{{</footnote>}}

**適切なテスト**.要件を理解しないと、適切なテストを作成できません。BDDのようなプロセスは;
要件が実際の*テストになる*ように記述されています。


## Understanding Roman numerals

> *”プロジェクトのほとんどの側面について最も無知であるインセプションの間、利用可能な時間を最大限に活用するには、考えられるすべての軸にわたって自分の無知を特定し、減らすことを試みることである”*
> -- *ダン・ノース、["Deliberate Discovery"](http://dannorth.net/2010/08/30/introducing-deliberate-discovery/)*

では、これはローマ数字のカタにどう当てはまるのでしょうか？私たちは、コードを1行書く前に、真剣にドメインエキスパートになるべきでしょうか？

私はイエスと言いたいです。

些細な問題であり、やり過ぎのようにも思えますが、やはりこれはカタなので、すべてのステップを注意深く、心を込めて練習するべきです。

さて、ローマ数字については何がわかるのでしょうか？

まず、ちょっとした[信頼できるソースからのバックグラウンドリーディング](https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%9E%E6%95%B0%E5%AD%97)によると、おそらく[画線法](https://ja.wikipedia.org/wiki/%E7%94%BB%E7%B7%9A%E6%B3%95)に似たものが起源であることがわかります。

![Tally marks](./200px-Tally_marks.svg.png)

これで、"I"から "IIII"までのシンプルなストロークと、"V"の異なるシンボルが説明できます。

これが進化して、10と50、100と500などの記号が追加されました。
この1と5で数える仕組みは、新旧の[アバカス](http://en.wikipedia.org/wiki/Roman_abacus)のデザインにも見られます。

![ローマのアバカス](./RomanAbacusRecon.jpg)
![現代のアバカス](./320px-Sharp-abacus-japan.jpg)

実際このシステムには聞いたこともない名前さえあります["二五進法"](https://ja.wikipedia.org/wiki/二五進法)
楽しくないですか?これからこの言葉を、可能な限り日常会話に取り入れようと思います。
(ちなみに、カウンターとして使われている小さな石は“calculi”と呼ばれています。

ずっと後の13世紀に、ある種の略語が追加され、"IIII"は"IV"、"VIIII"は"IX"に置き換えられました。この [減算表記](http://en.wikipedia.org/wiki/Subtractive_notation)
は、シンボルの順序が重要になることを意味します。これは純粋なタリーベースのシステムでは必要ありません。

このような追加要件は、開発ビジネスにおいて何も変わらないということです。

```text
法王:"至急、減法表記を追加してくれ--アラブ人が機能面で我々を打ち負かしている。"
あなた:"しかし、それには後方互換性がありません、閣下。破壊的な変更です！"
法王:"がんばれよ。来週までに必要なんだ。"
```

ローマ数字については十分に理解しましたが、要件を作成するのに十分な情報は得られましたか?

悲しいかな、不十分です。さらに調査すると、多くの矛盾があることが明らかになります。ローマ数字にはISOやANSI規格はありません。

もちろん、これは珍しいことではありません。要件に関する曖昧さは、ほとんどのソフトウェアプロジェクトに影響を与えています。
実際、開発者としての私たちの仕事の一部は、物事を明確にし、曖昧さを排除することです。そこで、これまでの知識に基づいて要件を作成しましょう。

## このカタの要求事項

> *”プログラマーは、その創意工夫や論理性ではなく、事例分析の完全性で評価されるべきである”*。
> -- *Alan Perlis, [Epigrams](http://cpsc.yale.edu/epigrams-programming)*

明確でテスト可能な要件を定めることこそ、プロジェクトを成功させるための重要なステップである、というのは誰もが同意すると思います。

私が"要件"について話すのは、書くのに6ヶ月かかる200ページの文書について話しているのではありません。
5~10分で書けるいくつかの箇条書きについて話しているだけです。

しかし...それらを持つことは重要です。コーディングの前に注意深く考えることは、実践すべき必須のスキルであり、
このステップは、どのようなコード・カタであっても、規律の一部として行うことをお勧めします。

私が見る限り、要件は次のとおりです。

* 出力は、シンボル"I","V","X","L","C","D"および"M"をそれぞれ使用して、1, 5, 10, 50, 100, 500,および1000を集計することによって生成される。
* 記号は降順で記述しなければならない:"M"を"D"の前に、"C"を"L"の前に、等々。
* 集計ロジックを使用すると、"I","X","C","M"を最大4回まで繰り返すことが可能であり、"V","L"および"D"は1回だけです。
  それ以上の場合、複数の割符は次の"上位"の割符に省略されます。
* 最後に、"IIII"=>"IV","VIIII"=>"IX","XXXX"=>"XL","LXXXX"=>"XC","CCCC"=>"CD","DCCCC"=>"CM"という6つの (オプションの) 置換ルールがあります。これらは降順ルールの例外です。

このリストに載っていないとても重要な要件がもう一つあります。

* 有効な値の範囲は?

これを明示的に記述しなければ、0と負の数を含むすべての整数が有効であると考えるのはたやすいことです。

数百万から数十億という大きな数字はどうでしょう?それらは許可されていますか?たぶん違うでしょう。

では、明示的に、有効な入力の範囲が0から4000であるとしましょう。その場合、入力が有効でなかった場合はどうなるのでしょうか?空の文字列を返す例外を投げますか?

F#のような関数型プログラミング言語で最も一般的な方法は、`Option`型を返すか、`Success/Failure`型を返すことです。
ここでは `Option`を使って要件を仕上げましょう。

* アラビア数字の0は、空の文字列にマッピングされます。
* 入力が<0または>4000の場合は`None`を返し、それ以外の場合は`Some(roman)`を返します。

このステップをまとめるために、ローマ数字について読み、いくつかの楽しいことを学び、次のステージのための明確な要件を考え出しました。
全部で5~10分しかかかりません。私には、それは有意義な時間でした。

## テストを書く

> *"ユニットテストは、怪物を探して暗い部屋に懐中電灯を照らすことに例えることができます。
> 部屋の中に光を当てて、それから隅々にある怖そうな場所すべてに光を当てましょう。
> 部屋に怪物が存在しないわけではありません--単に、あなたが懐中電灯を照らした場所に怪物が立っていないだけです。"*

要件ができたので、テストの作成を開始します。

元のビデオでは、テストは0から1のように段階的に展開されていました。

個人的には、そのアプローチには多くの問題があると思います。

まず、ご存知のように、TDDの主な目標はテストではなく*設計*です。

しかし、この小さな漸進的なデザインへのアプローチは、特に良い結果をもたらすとは思えません。

例えば、このビデオでは、 "I"ケースのテストから"II"ケースのテストに至るまで、実装の複雑さが大きく飛躍しています。しかしその理論的根拠を理解するのは少し難しいです
そして私には、これは一つ前のケースから自然に進化したというよりも、すでに答えを知っている人の手品のように思えます。

残念ながら、私はこれが厳密なTDDのアプローチでよく起こるのを見てきました。
うまくやっている途中で大きな障害にぶつかり、大きな再考とリファクタリングを強いられるかもしれません。

Uncle Bobの["Transformation Priority Premise"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html)アプローチを使用した厳密なTDDは、これは問題なく良いことであり、プロセスの一部であると主張しています。

個人的には、最初に最も難しい要件から始めたほうがよいと思います。最後まで放置するのではなく、リスクを前倒しで処理したいのです。

第二に、個々のケースをテストするのは好きではありません。私はテストが*全ての*項目を網羅することを望みます。これは常に実行可能というわけではありませんが、この場合のように、可能な場合は行うべきだと思います。

### 2つのテストの比較

ビデオで紹介したテストを、より一般的な要件ベースのテストと比較してみましょう。

ビデオで開発されたテストスイートは、明らかな入力のみをチェックし、さらに”念のため”に3497のケースもチェックします。以下は、F#に移植されたRubyのコードです。

```fsharp
[<Test>]
let ``For certain inputs, expect certain outputs``() =
    let testpairs = [
      (1, "I")
      (2, "II")
      (4, "IV")
      (5, "V")
      (9, "IX")
      (10, "X")
      // など
      (900, "CM")
      (1000, "M")
      (3497, "mmcdxcvii")
      ]
    for (arabic,expectedRoman) in testpairs do
       let roman = arabicToRoman arabic
       Assert.AreEqual(expectedRoman, roman)
```

このような入力があった場合、コードが要件を満たしていることにどの程度の自信があるでしょうか。

このような単純なケースでは、それなりに自信があるかもしれません。
しかし、このようなテスト方法では、文書化されていない”魔法の”テスト入力が使われているため、心配になります。

例えば、なぜ3497はどこからともなく摘出されたのでしょうか？それは、(a)1000より大きく、(b)4と9が入っているからです。
しかし、なぜそれが選ばれたのかは、テストコードには書かれていません。

さらに、このテストスイートと要求事項を比較すると、2番目と3番目の要求事項が全く明示的にテストされていないことがわかります。
確かに、3497のテストでは、暗黙のうちに順序付けの要件（”M”は”C”の前、”X”の前）をチェックしていますが、それは明示されていません。

では、そのテストとこのテストを比較してみましょう。

```fsharp
[<Test>]
let ``For all valid inputs, there must be a max of four "I"s in a row``() =
    for i in [1..4000] do
       let roman = arabicToRoman i
       roman |> assertMaxRepetition "I" 4
```

このテストでは，”I”の繰り返しは4回までしかできないという要件をチェックします。

TDDのビデオにあったものとは異なり、このテストケースは1つの入力だけでなく、可能なすべての入力をカバーしています。
このテストに合格すれば、コードがこの特定の要件を満たしていることを完全に確信することができます。

### プロパティベースのテスト

このようなテスト手法は、”プロパティベースのテスト”と呼ばれています。一般的に真でなければならない”プロパティ”を定義し、できるだけ多くの入力を生成して
可能な限り多くの入力を生成して、そのプロパティが真でないケースを探します。

この場合、4000個の入力すべてをテストすることができます。しかし、一般的には、私たちの問題にはもっと多くの入力の可能性があります。
そのため、一般的には入力の代表的なサンプルを使ってテストを行います。

ほとんどのプロパティベースのテストツールは、[Haskell's QuickCheck](http://en.wikipedia.org/wiki/QuickCheck)をモデルにしています。
これは、エッジケースをできるだけ早く見つけるために、”興味深い”入力を自動的に生成するツールです。
これらの入力には、ヌル、負の数、空リスト、非アスキー文字を含む文字列などがあります。

QuickCheckに相当するものは、F#の[FsCheck](https://fscheck.github.io/FsCheck/)など、現在ほとんどの言語で利用可能です。

プロパティベースのテストの利点は、多くの特殊なケースとしてではなく、一般的な用語で要件を考えることを余儀なくされることです。

つまり、`"4"という入力は "IV"に対応する`というテストではなく、`"4"を単位とした入力は、最後の2文字が "IV"になる`という、より一般的なテストを行うことができます。

### プロパティベースのテストの実装

上記の要件でプロパティベースのテストに切り替えるには、以下のようにコードをリファクタリングします。
(a)プロパティを定義する関数を作成し、(b)そのプロパティを入力範囲に対してチェックする。

リファクタリングしたコードは以下の通りです。

```fsharp
// すべての入力に対して真であるべきプロパティを定義する
let ``has max rep of four Is`` arabic =
   let roman = arabicToRoman arabic
   roman |> assertMaxRepetition "I" 4

// すべての入力を明示的に列挙する...
[<Test>]
let ``For all valid inputs, there must be a max of four "I"s``() =
    for i in [1..4000] do
       //プロパティが有効であることをチェックする
       ``has max rep of four Is`` i

// ...または、FsCheckを使って入力を生成します。
let isInRange i = (i >= 1) && (i <= 4000)
// 入力が範囲内にあるということは、最大4つのIsを持っていることを意味する
let prop i = isInRange i ==> ``has max rep of four Is`` i
// すべての入力にこのプロパティをチェックする
Check.Quick prop

```


また、例えば、40 => "XL"の置換ルールをテストしたいとします。

```fsharp
// すべての入力に対して真であるべきプロパティを定義する
let ``if arabic has 4 tens then roman has one XL otherwise none`` arabic =
   let roman = arabicToRoman arabic
   let has4Tens = (arabic % 100 / 10) = 4
   if has4Tens then
       assertMaxOccurs "XL" 1 roman
   else
       assertMaxOccurs "XL" 0 roman

// すべての入力を明示的に列挙する...
[<Test>]
let ``For all valid inputs, check the XL substitution``() =
    for i in [1..4000] do
       ``if arabic has 4 tens then roman has one XL otherwise none`` i

// ...あるいは、FsCheckを使って入力を生成することもできます。
let isInRange i = (i >= 1) && (i <= 4000)
let prop i = isInRange i ==> ``if arabic has 4 tens then roman has one XL otherwise none`` i
Check.Quick prop
```

プロパティベースのテストについてこれ以上説明するつもりはありませんが、魔法の入力を使って手作業でケースを作成するよりもメリットがあることはお分かりいただけると思います。

*[この記事のコード](https://gist.github.com/swlaschin/8409306)には、プロパティベースのテストスイートが完備されています。 *

## Requirements Driven Design™ (要件駆動設計)

この時点で、実装を開始できます。

TDDビデオとは異なり、私は*テストケース*ではなく*要件*を繰り返して実装を構築したいと思います。
このための覚えやすいフレーズが必要なので、Requirements Driven Design™と呼びます。Requirements Driven Design Manifestoが近日公開されることにご注目ください。

そして、個々の入力を1つずつ処理するコードを実装するのではなく、できるだけ多くの入力ケース (できればすべての入力ケース) をカバーするように実装したいと思っています。
新しい要件が追加されるたびに、その要件を満たしていることを確認するためのテストを使用して、実装が変更または改良されます。

しかし、これはビデオで示されているようなTDDではないでしょうか?

いいえ、そんなことはありません。TDDデモンストレーションは*テスト駆動*でしたが、*要件駆動*ではありませんでした。"I"へのマッピング1と"II"へのマッピング2はテストですが、私の考えでは真の要件ではありません。
適切な要件は、ドメインに対する洞察に基づいています。2つのマップを"II"にマッピングしてテストしただけでは、その洞察は得られません。

### とてもシンプルな実装

誰かの実装を批判したということは、私が行動で示す時が来たということです。

では、私が考えられる最も簡単な実装は何でしょうか?

アラビア語の数字をタリーマークに変換するのはどうでしょうか？ 1は "I"、2は "II"というように。

```fsharp
let arabicToRoman arabic =
   String.replicate arabic "I"
```

これを実際にやってみましょう。

```fsharp
arabicToRoman 1    // "I"
arabicToRoman 5    // "IIIII"
arabicToRoman 10   // "IIIIIIIIII"
```

このコードは、すべての入力に対して、実際には最初と2番目の要件を満たしています。

もちろん、4000ものタリーマークがあるのはあまり有用ではありません。それがローマ人がタリーマークを省略し始めた理由であることは間違いありません。

ここでドメインに対する洞察が得られます。割符が省略されていることがわかれば、コードでそれをエミュレートできます。

5つのマークをすべて"V"に変換しましょう。

```fsharp
let arabicToRoman arabic =
   (String.replicate arabic "I")
    .Replace("IIIII","V")

// テスト
arabicToRoman 1 // "I"
arabicToRoman 5 // "V"
arabicToRoman 6 // "VI"
arabicToRoman 10 // "VV"
```

しかし、今度は "V"の数を増やすことができます。2つの "V"を "X"に折りたたむ必要があります。

```fsharp
let arabicToRoman arabic = (String.replicate arabic)
   (String.replicate arabic "I")
    .Replace("IIIII", "V")
    .Replace("VV", "X")

// test
arabicToRoman 1    // "I"
arabicToRoman 5    // "V"
arabicToRoman 6    // "VI"
arabicToRoman 10   // "X"
arabicToRoman 12   // "XII"
arabicToRoman 16   // "XVI"
```

ご理解いただけたと思います。省略形をどんどん追加していくことができます。

```fsharp
let arabicToRoman arabic =
   (String.replicate arabic "I")
    .Replace("IIIII","V")
    .Replace("VV","X")
    .Replace("XXXXX","L")
    .Replace("LL","C")
    .Replace("CCCCC","D")
    .Replace("DD","M")

// test
arabicToRoman 1    // "I"
arabicToRoman 5    // "V"
arabicToRoman 6    // "VI"
arabicToRoman 10   // "X"
arabicToRoman 12   // "XII"
arabicToRoman 16   // "XVI"
arabicToRoman 3497 // "MMMCCCCLXXXXVII"
```

これで完了です。最初の3つの要件を満たしました。

もし、4と9の省略形を追加したい場合は、すべてのタリーマークが蓄積された後、最後に追加することができます。

```fsharp
let arabicToRoman arabic =
   (String.replicate arabic "I")
    .Replace("IIIII","V")
    .Replace("VV","X")
    .Replace("XXXXX","L")
    .Replace("LL","C")
    .Replace("CCCCC","D")
    .Replace("DD","M")
    // optional substitutions
    .Replace("IIII","IV")
    .Replace("VIV","IX")
    .Replace("XXXX","XL")
    .Replace("LXL","XC")
    .Replace("CCCC","CD")
    .Replace("DCD","CM")


// test
arabicToRoman 1    // "I"
arabicToRoman 4    // "IV"
arabicToRoman 5    // "V"
arabicToRoman 6    // "VI"
arabicToRoman 10   // "X"
arabicToRoman 12   // "XII"
arabicToRoman 16   // "XVI"
arabicToRoman 40   // "XL"
arabicToRoman 946  // "CMXLVI"
arabicToRoman 3497 // "MMMCDXCVII"
```

このアプローチの気に入っている点は以下の通りです。

* 再帰的な設計に飛びつくのではなく、ドメインモデル（タリーマーク）を理解することから導き出されます。
* その結果、実装は要件に非常に忠実に従います。実際、基本的には自分で書いています。
* このようなステップ・バイ・ステップのアプローチをとることで、他の人がコードを見ただけで、そのコードが正しいと確信できるようになります。
  誰かを混乱させるような再帰や特別なトリックはありません。
* 実装は、すべての入力に対して、常に出力を生成します。中間段階では、すべての要件を満たしていない場合でも
  少なくとも、次に何をすべきかを教えてくれる出力（例："VV"にマッピングされた10）を生成します。

確かに、4000個の "I"を含む文字列を作成することは、最も効率的なコードとは言えないかもしれません。もちろん、もっと効率的なアプローチは
もちろん、より効率的なアプローチとしては、入力から直接、大きな集計値（”M”→”D”→”C”）を差し引くことで、TDDのビデオで紹介されている再帰的な解決策が得られます。

しかし一方で、この実装は十分に効率的かもしれません。
要求事項には、性能の制約については何も書かれていません（YAGNIとか？-- だから、このままにしておきたいと思います。

### 二五進法の実装

"二五進法"という言葉を再び使いたいので、他の実装せずにはいられません。

この実装も、ドメイン (この場合はローマの算盤) の理解に基づいています。

算盤では、一般的なアラビア表記と同様に、各行または配線が小数点を表します。
しかし、その場所の数字は、数字に応じて2つの異なる記号で符号化することができます。

例をいくつか示します。

* 10の位の1は"X"で符号化される
* 10の位の2は"XX"で符号化される
* 10の位の5は"L"で符号化される
* 10の位の6は"LX"で符号化される

といった具合です

これは、そろばん上の珠を文字列表現に変換するアルゴリズムに直接つながります。

* 入力した数値を、数十、数百、数千の単位に分割します。これは、算盤の各行または配線を表します。
* "二五進法"の表現とその場所の適切な記号を使用して、各場所の数字を文字列にエンコードします。
* 各場所の表現をまとめて1つの出力文字列にします。

このアルゴリズムを直接変換した実装を次に示します。

```fsharp
let biQuinaryDigits place (unit,five) arabic =
    let digit =  arabic % (10*place) / place
    match digit with
    | 0 -> ""
    | 1 -> unit
    | 2 -> unit + unit
    | 3 -> unit + unit + unit
    | 4 -> unit + unit + unit + unit
    | 5 -> five
    | 6 -> five + unit
    | 7 -> five + unit + unit
    | 8 -> five + unit + unit + unit
    | 9 -> five + unit + unit + unit + unit
    | _ -> failwith "Expected 0-9 only"

let arabicToRoman arabic =
    let units = biQuinaryDigits 1 ("I","V") arabic
    let tens = biQuinaryDigits 10 ("X","L") arabic
    let hundreds = biQuinaryDigits 100 ("C","D") arabic
    let thousands = biQuinaryDigits 1000 ("M","?") arabic
    thousands + hundreds + tens + units

```

上のコードでは、4と9のケースの略語を生成していないことに注意してください。
しかし、これを簡単に修正することができます。10を表す記号を渡して，4と9の場合のマッピングを次のように調整するだけです。

```fsharp
let biQuinaryDigits place (unit,five,ten) arabic =
  let digit =  arabic % (10*place) / place
  match digit with
  | 0 -> ""
  | 1 -> unit
  | 2 -> unit + unit
  | 3 -> unit + unit + unit
  | 4 -> unit + five // changed to be one less than five
  | 5 -> five
  | 6 -> five + unit
  | 7 -> five + unit + unit
  | 8 -> five + unit + unit + unit
  | 9 -> unit + ten  // changed to be one less than ten
  | _ -> failwith "Expected 0-9 only"

let arabicToRoman arabic =
  let units = biQuinaryDigits 1 ("I","V","X") arabic
  let tens = biQuinaryDigits 10 ("X","L","C") arabic
  let hundreds = biQuinaryDigits 100 ("C","D","M") arabic
  let thousands = biQuinaryDigits 1000 ("M","?","?") arabic
  thousands + hundreds + tens + units
```

繰り返しになりますが、これらの実装はどちらも非常に素直で、検証も簡単です。コードには微妙なエッジケースは潜んでいません。

## レビュー

私はこの記事の最初に、TDDのデモンストレーションに腹を立てていました。その理由と、私のアプローチがどう違うのかをおさらいしましょう。

**必要なもの**

TDDのデモンストレーションビデオでは、要求事項を文書化することを全く試みていませんでした。
これは、特に学習中の人にとっては危険なことだと思います。

コーディングを始める前に、自分が何をしようとしているのかを明確にする努力を常にしてほしいと思います。

ほんの少しの努力で、私は後で検証に使えるような明確な要求事項を考え出しました。

また、TDDのデモでは残念ながら不足していた、有効な入力の範囲も明示的に文書化しました。

**ドメインを理解する

たとえ要件が明示されていたとしても、自分が作業しているドメインを本当に*理解するために時間を費やすことは常に価値があると思います。

このケースでは、ローマ数字が集計ベースのシステムであることを理解していたことが、後の設計に役立ちました。(さらに、”2進法”の意味を知り、この記事で使うことができました！）。)

**ユニットテスト

TDDデモのユニットテストは、1つのケースずつ作られました。最初はゼロ、次に1、というように。

上に書いたように、私はこのアプローチにとても違和感を感じています。なぜなら、(a)それが良いデザインにつながるとは思えないし、(b)1つのケースがすべての可能な入力をカバーしていないからです。

*直接*要件に対応する*テストを作成することを強くお勧めします。要件が良い場合、テストは一度に多くの項目をカバーすることになります。
そうすれば、できるだけ多くの項目をテストすることができます。

理想的には、QuickCheckのようなプロパティベースのテストツールを使用します。これにより、このアプローチの実装が大幅に容易になるだけでなく、
設計のプロパティをに設定します。これにより、あいまいな要件を明確にすることができます。

**実装**

最後に、TDDビデオで示した再帰的な実装とはまったく異なる2つの実装について説明しました。

どちらの設計も、ドメインの理解から直接導かれたものです。1つは割符の使用、もう1つはそろばんの使用です。

私の考えでは、どちらのデザインも再帰なしで理解しやすくなりました!――それが自信に繋がるのです。

## まとめ

*(以下のコメントをもとに追加しました。)*

はっきりさせておきたいのですが、私はTDDに全然問題がないし、カタも問題ないと思います。

しかし、私が懸念しているのは、この種の"ディーブ・イン"デモ、つまり初心者や学習者が無意識のうちに次のような (暗黙の) 教訓を学んでしまうのではないかということです。

* 質問せずに、与えられた要件を受け入れても構わない。
* ゴールを明確にしないまま仕事をしても問題ない。
* すぐにコーディングを開始してもよい。
* 非常に具体的なテスト(例えば魔法の数字を使って)を作成することは問題ない。
* ハッピーパスだけを考えたらいい。
* 全体を見ずに微細なリファクタリングを行っても構わない。

個人的には、もしあなたが*プロの*開発者になるために*訓練*をしているなら、あなたは以下のことをすべきだと思います。

* コーディングを始める前に、できるだけ多くの情報を求める練習をすること。
* (不明確な情報にもとに) テスト可能な要件を作成する練習をする。
* すぐにコーディングするのではなく、思考 (分析と設計) を練習する。
* 特定のテストではなく、包括的なテストを作成する練習をすること。
* 不適切な入力、例外、エラーについて考え、対処する練習をします。
* (マイクロ・リファクタリングではなく) メジャー・リファクタリングを実践して、 [共有レイヤ](http://jonjagger.blogspot.co.uk/2009/10/how-buildings-learn-chapter-2-shearing.html) がどこにあるべきかを直感的に判断できるようなること。

これらの原則はすべて、TDD (あるいは少なくともTDDの ["London"school](http://codemanship.co.uk/parlezuml/blog/?postid=987) ) やプログラミング・カタとも完全な互換性があります。衝突はありませんし、私はそれらがなぜ論争になるのか理解できません。

## あなたはどう思いますか？

多くの人がこの投稿に同意しないと思います。私は (文化的な) 議論に賛成です。下、もしくはRedditにコメントを残してください。

この記事の完全なコードを見たければ、 [Gist](https://gist.github.com/swlaschin/8409306) から入手できます。
gistには、両方の実装に対する完全なプロパティベースのテストも含まれます。

