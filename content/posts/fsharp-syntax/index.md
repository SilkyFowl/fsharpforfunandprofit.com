---
layout: post
title: "F# syntax: indentation and verbosity"
description: "Understanding the offside rule"
date: 2012-05-18
nav: thinking-functionally
seriesId: "Expressions and syntax"
seriesOrder: 5
---

F#のシンタックスはほとんどわかりやすいものです。しかし、よくあるインデントのエラーを避けるために、理解しておくべきルールがいくつかあります。 もしあなたがPythonのような空白を気にする言語に慣れているのであれば、F#のインデントのルールは微妙に異なっていることに注意してください。

## インデントと"オフサイド"ルール ##

サッカーでは、オフサイド・ルールといって、ある状況下では、プレーヤーはボールの後ろまたは水平にいるべきなのに、ボールの"前"にいてはいけないというものです。"オフサイドライン"とは、選手が越えてはいけないラインのことです。F#では、同じ言葉を使って、インデントを開始しなければならないラインを表現しています。サッカーと同じように、ペナルティを避けるためのコツは、ラインがどこにあるのかを知り、それを越えないようにすることです。

一般的には、オフサイドラインが設定されると、すべての式はそのラインに合わせなければなりません。

```fsharp
//文字列
//3456789
let f =
  let x=1     // オフサイドラインは3列目にある
  let y=1     // この線は3列目から始まらなければならない
  x+y         // この線は3列目から始まること

let f =
  let x=1     // オフサイドの線は 3 列目にある
   x+1        // おっと！4列目から始まらない
              // error FS0010: バインディング内の予期せぬ識別子

let f =
  let x=1    // オフサイドラインは3列目にある
 x+1         // オフサイドです! ボールに先行されている!
             // error FS0588: 値または関数定義が不完全です。これが式の中にある場合、
             // 式の本体を 'let' キーワードと同じ列にインデントする必要があります。
```

様々なトークンがきっかけとなって、新しいオフサイドラインが作られることがあります。例えば、F#がlet式の中で使われている"`=`"を見ると、次に出会った記号や単語の位置に新しいオフサイドラインが作られます。

```fsharp
//文字列
//34567890123456789
let f =   let x=1  // 線は11列目になりました（"let x="の開始）。
          x+1      // 今後は11列目から始めなければならない

//        |        // 今後は列11から始めなければならない
let f =   let x=1  // 線は11列目になりました("let x="の開始点)
         x+1       // オフサイドだ!


// |        // 4列目のオフサイドライン
let f =
   let x=1  // =記号の後の最初の単語がラインを定義する
            // オフサイドラインは4列目になった
   x+1      // 今から4列目から始めなければならない
```

他のトークンも同様の動作をします。例えば、括弧、"`then`"、"`else`"、"`try`"、"`finally`"、"`do`"、マッチ節の"`->`"などがあります。

```fsharp
//文字列
//34567890123456789
let f =
   let g = (
    1+2)             // "("の後の最初の文字を定義する。
                     // 5列目で新しい行を作る
   g

let f =
   if true then
    1+2             // "then "の後の最初の文字で定義する
                    // 5列目で改行される

let f =
   match 1 with
   | 1 ->
       1+2          // "->"の後の最初の文字で定義する
                    // 8行目で改行する
```

オフサイドラインは入れ子にすることができ，期待通りにプッシュ，ポップされます:

```fsharp
//文字列
//34567890123456789
let f =
   let g = let x = 1 // "let g ="の後の最初の単語
                     // 12行目に新しいオフサイドラインを定義する
           x + 1     // "x"は12行目で揃える必要がある
                     // オフサイドラインのスタックをポップします
   g + 1             // 前の行に戻る。"g"は 4行目で揃える必要がある。
                     // 4行目で揃える
```

新しいオフサイドラインは、スタック上の前のラインよりも先に進むことはできない。

```fsharp
let f =
   let g = (         // 4行目 に新しいラインを定義する。
  1+2)               // oops! 4以下の新しい線は定義できない
   g
```

## 特別なケース ##

コードのフォーマットをより柔軟にするために、いくつかの特殊なケースが用意されています。 例えば、`if-then-else`式や`try-catch`式の各部分の開始位置を揃えるなど、自然に思えるものも多いでしょう。しかし、当然とは言えないものもあります。

例えば、"+"、"|>"、">>"などの中置演算子は、その長さにスペースを加えた分だけ行の外に出ることができます。

```fsharp
//文字列
//34567890123456789
let x =  1   // 10行目に新しい行を定義する
       + 2   // "+"は行の外側にあってもよい
       + 3

let f g h =   g   // 15行目に改行を定義します。
           >> h   // ">>" は線の外側にあってもよい
```

中置演算子で行を開始した場合、その行は整列を厳密に行う必要はありません。

```fsharp
let x =  1   // 10行目に新しい行を定義する
        + 2   // 行頭にある 中置演算子はカウントしない
             * 3  // "*"で始まるので、整列する必要はありません。
         - 4  // "-"で始まるので、整列する必要はありません
```

"`fun`" キーワードが式の先頭にある場合、"fun" はオフサイドの新しい行を *開始しません* 。

```fsharp
//文字列
//34567890123456789
let f = fun x ->  // "fun"は9行目で新しい行を定義するはずです。
   let y = 1      // しかし，そうではない．本当の行はここから始まる。
   x + y
```

### もっと知りたい

インデントがどのように機能するかについては、さらに多くの詳細がありますが、上記の例でほとんどの一般的なケースはカバーできるでしょう。もっと詳しく知りたい方は、F#の完全な言語仕様書がMicrosoftから[ダウンロード可能なPDF](http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf)で提供されていますので、ぜひ読んでみてください。

## 冗語構文

デフォルトでは、F#はブロック構造を示すためにインデントを使用します--これは"軽量"構文と呼ばれます。インデントを使用しない別の構文もあります。これは"冗語"構文と呼ばれます。冗語構文では、インデントを使用する必要はなく、空白も重要ではありません。ただし、次のような多くのキーワードを使用する必要があるという欠点があります。

* "`in`"キーワードを"let"と"do"の束縛の次に置きます。
* "`begin`"/"`end`"キーワード (if-then-elseなどのコードブロック用)
* "`done`"キーワードをループの最後に置く
* 型定義の最初と最後にあるキーワード

以下に、本来なら受け入れられない、奇抜な字下げを伴う冗長構文の例を示します。

```fsharp
#indent "off"

      let f =
    let x = 1 in
  if x=2 then
begin "a" end else begin
"b"
end

#indent "on"
```

冗語構文は、"軽量"モードでも常に使用できます。たとえば、1行の式に"let"を埋め込む場合は、次のようにします。

```fsharp
let x = let y = 1 in let z = 2 in y + z
```

その他にも、冗語構文を使いたい場合があります。

* 生成されたコードを出力するとき
* OCamlとの互換性を保つため
* 視覚障害者や目の不自由な方がスクリーンリーダーを使用する場合
* F#パーサーが使用する抽象的なシンタックスツリーについて理解を深めるため。

これらのケース以外では、冗語構文は実際にはほとんど使われません。
