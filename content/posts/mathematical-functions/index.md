---
layout: post
title: "Mathematical functions"
description: "The impetus behind functional programming"
date: 2012-05-02
nav: thinking-functionally
seriesId: "Thinking functionally"
seriesOrder: 2
---

関数型プログラミングを支える原動力は数学にあります。数学関数には、関数型言語が実用的に模倣する非常に優れた特性が数多くあります。

まず、数値に1を加算する数学関数から始めましょう。

	Add1(x) = x+1

これは実際には何を意味するのでしょうか？ それはとても簡単なことです。つまり、ある数字から始まり、それに1を加える演算があるということです。

用語をいくつか紹介します。

* 関数への入力として使用できる値の集合は、*定義域(domain)*と呼ばれます。この場合は、実数の集合である可能性がありますが、ここでは簡単にするために、整数のみに制限します。
* この関数からの出力値のセットは、*値域(range)* (厳密には終域(codomain)の像) と呼ばれます。この場合は、整数の集合でもあります。
* この関数は、定義域から終域への*写像(map)*といいます。

![](./Functions_Add1.png)

この定義をF#で表現すると以下のようになります。

```fsharp
let add1 x = x + 1
```

これをF#のインタラクティブウィンドウに入力すると（ダブルセミコロンを忘れずに），結果（関数の「シグネチャ」）が表示されます。

```fsharp
val add1 : int -> int
```

この出力を詳細に見てみましょう。

* 全体の意味は、「関数 `add1` は整数（定義域）を整数（値域）への写像」です．
* "`add1`"は "val"として定義されています、"value"の略です。ふむふむ、どういうことでしょう？ 値については後で説明します。
* 「`->`」という矢印表記は、定義域と値域を示すのに使われます。この場合、定義域は `int` 型であり、値域も `int` 型です。

また、型が指定されていないにもかかわらず、F#コンパイラはこの関数がintを扱うものだと推測していることにも注目してください。(これは調整可能ですか? はい、後で説明します。)

## 数学関数の主要な特性 ##

数学関数には、手続き型プログラミングで使用する関数とはまったく異なる特性があります。

* 関数は、与えられた入力値に対して常に同じ値を返します。
* 関数には副作用はありません。

これらの特性は非常に強力な利点となるため、関数型プログラミング言語ではこれらの特性を強制するように設計されています。では、1つずつ順番に見ていきましょう。

### 数学関数は、与えられた入力に対して常に同じ結果を出力する ###

命令型プログラミングでは、関数は何かを「〜する」、または何かを「計算する」と考えます。数学関数は、入力から出力への単なるマッピングであり、計算は行いません。実際、関数を定義する別の方法は、単純にすべてのマッピングを組み合わせたものと考えることです。例えば、大雑把な方法で 「`add1`」 を定義することができます。
関数（C#）を次のように定義できます:

```csharp
int add1(int input)
{
   switch (input)
   {
   case 0: return 1;
   case 1: return 2;
   case 2: return 3;
   case 3: return 4;
   etc ad infinitum
   }
}
```

もちろん、ありとあらゆる整数にケースを用意することはできませんが、原理は同じです。全く計算をしていない、ただのルックアップであることがわかります。

### 数学関数は副作用がない ###

数学関数では、入力と出力は論理的に2つの異なるものであり、どちらも事前定義されています。この関数は、入力または出力を変更するのではなく、既存の入力値を定義域から値域へ既定の出力値へ定める写像です。

つまり、関数*を評価しても、入力には何の影響も与えません*。関数を評価することは、何かを実際に計算したり操作したりすることではありません。ただの美化されたルックアップです。

この値の「不変性」は微妙ですが、非常に重要です。数学をやっているのなら、加算時に使用した数値が勝手に変わるなんてありえません！たとえば、次のような場合:

	x = 5
	y = x+1

xに1を加えても変更されないでしょう。別の数字 (y) が返ってきて、xは変更されません。数学の世界では、整数は不変の集合としてすでに存在しており、「add1」関数は単にそれらの間の関係を定義しているにすぎません。

### 純粋関数のもつ力 ###

再現可能な結果を持ち、副作用のない関数は 「純粋関数」 と呼ばれ、いくつかの興味深いことを行うことができます:

* 簡単に並列化できます。たとえば、1から1000までの全整数をとり、1000個の異なるCPUを用意して、それぞれのCPUで、対応する整数の`add1`関数を同時に実行させることができます。これは、各CPU間で相互作用が必要ないことを知っていれば安全です。ロック、ミューテックス、セマフォなどは必要ありません。
* 関数は、出力が必要なときに評価するだけで、遅延的に使用できます。今評価しても、後で評価しても、答えは変わりません。
* ある入力に対して関数を評価する必要があるのは一度だけで、その結果をキャッシュすることができます。なぜなら、同じ入力が常に同じ出力を与えることがわかっているからです。
* 純粋な関数が多数ある場合は、任意の順序で評価できます。この場合も、最終的な結果には影響しません。

ですから、プログラミング言語で純粋関数を作成できれば、すぐに多くの強力なテクニックが得られます。実際、F#ではこれらすべてのことができます:

* 並列処理の例は、[「なぜF#を使うのか?」](/series/why-use-fsharp.html) シリーズですでに説明しました。
* 関数の遅延評価については、[「最適化」](/series/optimization.html) で説明します。
* 関数の結果のキャッシュは「メモ化」と呼ばれ、[「最適化」](/series/optimization.html) シリーズでも取り上げます。
* 評価の順序を気にしないことで、並行プログラミングが非常に簡単になり、関数が並べ替えられたりリファクタリングされたりしてもバグが発生しません。

## 「役に立たない」数学関数の特性 ##

数学関数には、プログラミングではあまり役に立たないと思われる特性もあります。

* 入力値と出力値は不変である
* 関数の入出力は常に1つだけである

これらの特性は、関数型プログラミング言語の設計にも反映されています。それぞれを順番に見ていきましょう。

**入力値と出力値は不変である**

不変の値は理論的には良いアイデアのように思えるかもしれませんが、従来の方法で変数に代入できない場合、実際にどのようにして作業を行うことができるのでしょうか。

これはあなたが考えているほどの問題ではないと断言できます。この連載を読み進めていくうちに、この方法が実際にどのように行われるかを理解することができます。

**数学関数の入出力は常に1つだけである**

図からわかるように、数学関数の入出力は常に1つだけです。これは関数型プログラミング言語にも当てはまりますが、関数型プログラミング言語を初めて使用するときには分かりにくいかもしれません。

これは非常に困ったことです。2つ (またはそれ以上) のパラメータを持つ関数なしで、どうすれば実用的なことが出来るのでしょうか?

そう、それを実行する方法があり、さらにF#では完全に透過的です。これは「カリー化」 と呼ばれており、近いうちに投稿される予定です。

実際、後で説明するように、この2つの「役に立たない」 特性は、信じられないほど便利であり、関数型プログラミングを強力なものにする鍵となります。
