---
レイアウト: ポスト
タイトルは "ラッパータイプの詳細"
説明 "リストもラッパータイプになることを発見しました"
日付: 2013-01-24
nav: 機能的に考える
seriesId: "Computation Expressions"
seriesOrder: 5
---

前回の記事では、「ラッパー型」の概念とコンピュテーション式との関係を見てきました。今回は、どのような型がラッパー型に適しているかを調べてみましょう。

## どんな種類の型がラッパー型になるのか？

すべてのコンピュテーション式が関連するラッパー型を持たなければならないとしたら、どのような種類の型がラッパー型として使用できるのでしょうか？また、何か特別な制約や制限がありますか？

一般的なルールが1つあります。

一般的なルールは以下の通りです。 * **ジェネリックなパラメータを持つ型はすべてラッパー型として使用できます**。

つまり、例えば、`Option<T>`や`DbResult<T>`などをラッパー型として使用することができ、これまで見てきた通りです。また，`Vector<int>`のように型のパラメータを制限するラッパー型を使うこともできます。

しかし，`List<T>`や`IEnumerable<T>`のような他の汎用型はどうでしょうか？これらは使用できないのでしょうか？ 実は、使えるのです。その方法については後ほど説明します。

## 非ジェネリックなラッパータイプは使えますか？

ジェネリックなパラメータを持たないラッパータイプを使用することは可能でしょうか？

例えば、先ほどの例で、文字列の加算を行う試みを見てみましょう。`"1" + "2"`.
この場合、`string` を `int` のラッパー型として扱うことはできないでしょうか? それはクールなことですよね。

試してみましょう。`Bind` と `Return` のシグネチャを利用して、実装を進めていきましょう。

* `Bind` はタプルを取ります。タプルの最初の部分はラップされた型（この場合は`string`）で、タプルの2番目の部分はラップされていない型を受け取り、それをラップされた型に変換する関数です。 この場合は、`int -> string`となります。
* `Return` はラップされていない型（この場合は `int` ）を受け取り、それをラップされた型に変換します。 つまり、この場合、`Return`のシグネチャは `int -> string` となります。

これは実装にどのように役立つのでしょうか？

* 「リラップ」関数である `int -> string` の実装は簡単です。これは単にintの "toString "です。
* バインド関数は、文字列をintにアンラップして、それを関数に渡さなければなりません。それには `int.Parse` を使えばいいのです。
* しかし、文字列が有効な数値ではないために、バインド関数が文字列をアンラップできない場合はどうなるでしょうか。この場合でも、バインド関数はラップされた型（文字列）を返さなければなりません。つまり、「error」などの文字列を返せばいいのです。

ビルダークラスの実装は以下の通りです。

```fsharp
タイプ StringIntBuilder() =

    メンバー this.Bind(m, f) =
        let b,i = System.Int32.TryParse(m)
        b,iにマッチするもの
        | false,_ -> "エラー"
        | b,iとのマッチング｜true,i -> f i

    メンバー this.Return(x) =
        sprintf "%i" x

let stringint = new StringIntBuilder()
```

では、実際に使ってみましょう。

```fsharp
let good =
    ストリングイント{
        i = "42"
        j = "43"
        i+jを返す
        }
printfn "good=%s" good
```

また、文字列の1つが無効な場合はどうなるでしょうか？

```fsharp
let bad =
    文字列int {
        let! i = "42"
        let! j = "xxx"
        i+jを返す
        }
printfn "bad=%s" バッド
```

これで、ワークフローの中で文字列を整数として扱えるようになりました。

しかし、ちょっとした問題があります。

ワークフローに入力を与え、それを（`let!`で）アンラップし、すぐに（`return`で）何もせずにリラップしたとしましょう。どうなるでしょうか？

```fsharp
let g1 = "99"
let g2 = stringint {
            let! i = g1
            iを返す
            }
printfn "g1=%s g2=%s" g1 g2
```

問題ありません。入力の`g1`と出力の`g2`は、期待通り同じ値になりました。

しかし、エラーの場合はどうでしょうか？

```fsharp
let b1 = "xxx"
let b2 = stringint {
            let! i = b1
            iを返す
            }
printfn "b1=%s b2=%s" b1 b2
```

このケースでは、いくつかの予期しない動作があります。入力の `b1` と出力の `b2` は *同じ値ではありません* 。矛盾が生じています。

これは実際に問題になるでしょうか？わかりません。でも、私なら避けて、オプションのように、すべてのケースで一貫性のある別のアプローチを使います。


## ラッパータイプを使用するワークフローのルール

ここで質問です。この2つのコードフラグメントの違いは何でしょうか？また、異なる動作をすべきでしょうか？

```fsharp
// リファクタリング前のフラグメント
myworkflow {
    let wrapped = // 何らかのラップされた値
    let! unwrapped = wrapped
    return unwrapped
    }

// リファクタリングされたフラグメント
マイワークフロー {
    let wrapped = // ラップされた値
    return! wrapped
    }
```

答えはノーで、両者の動作は異なるべきではありません。唯一の違いは、2つ目の例では `unwrapped` の値がリファクタリングされて、`wrapped` の値が直接返されていることです。

しかし、前のセクションで見たように、注意しないと不整合が発生してしまいます。 そのため、あなたが作る実装は、いくつかの標準的なルールに従うようにしてください。

**ルール1：ラップされていない値から始めて、それを（`return`を使って）ラップし、その後（`bind`を使って）ラップを解除した場合、必ず元のラップされていない値が戻ってくるはずである。

このルールと次のルールは、値をラップしたりアンラップしたりする際に情報を失わないようにするためのものです。このルールと次のルールは、値をラップしたりアンラップしたりする際に情報を失わないようにするためのものです。

コードでは、次のように表現されます。

```fsharp
myworkflow {
    let originalUnwrapped = something

    // それを包む
    let wrapped = myworkflow { return originalUnwrapped } // 包み込む。

    // アンラップする
    let! newUnwrapped = wrapped

    // 同じであることを証明する
    assertEqual newUnwrapped originalUnwrapped
    }
```

**規則 2: ラップされた値から始まり、(`bind` を使用して)ラップを解除し、(`return` を使用して)ラップした場合、常に元のラップされた値を返すべきである。

これは、上記の `stringInt` ワークフローが破ってしまったルールです。ルール1と同様に、これは明らかに要求されるべきことです。

コードでは、次のように表現されます。

```fsharp
myworkflow {
    let originalWrapped = something

    let newWrapped = myworkflow { (オリジナルのラップ)

        // アンラップする
        let! unwrapped = originalWrapped

        // ラッピング
        return unwrapped
        }

    // 同一であることを証明する
    assertEqual newWrapped originalWrapped
    }
```

**ルール3：子ワークフローを作成する場合、メインワークフローのロジックをインライン化した場合と同じ結果を得なければならない**。

このルールは、コンポジションが正しく動作するために必要であり、また、「抽出」リファクタリングはこれが真である場合にのみ正しく動作します。

一般的には、いくつかのガイドライン（これについては後の記事で説明します）に従えば、無料でこれを得ることができます。

コードでは、これは次のように表現されます。

```fsharp
// インライン化
let result1 = myworkflow {.
    let! x = originalWrapped
    let! y = f x // x に対する何らかの関数
    return! g y // y に対する何らかの関数
    }

// 子ワークフローの使用（"抽出 "リファクタリング
let result2 = myworkflow {
    let! y = myworkflow {
        let! x = オリジナルラップ
        return! f x // xに対する何らかの関数
        }
    return! g y // yに関する何らかの関数
    }

// ルール
assertEqual result1 result2
```


## ラッパー型としてのリスト

先ほど、`List<T>`や`IEnumerable<T>`などの型がラッパー型として使えると言いました。しかし、これは一体どういうことなのでしょうか？ラッパー型とアンラップ型の間には一対一の対応関係はありません。

ここで、「ラッパー型」の例えは少し誤解を招く恐れがあります。代わりに、`bind`をある式の出力と別の式の入力を接続する方法として考えることに戻りましょう。

これまで見てきたように、`bind`関数は型を「アンラップ」して、アンラップされた値に継続関数を適用しています。 しかし、定義には、アンラップされた値が*1つだけでなければならないとは書かれていません。継続関数をリストの各項目に順番に適用できない理由はありません。

言い換えれば、リストと継続関数を受け取り、継続関数が一度に一つの要素を処理するような`bind`を、次のように書くことができるはずです。

```fsharp
bind( [1;2;3], fun elem -> // 1つの要素を使った式 )
```

そして、この概念を使えば、次のようにいくつかのbindを連鎖させることができるはずです。

```fsharp
let add =
    bind( [1;2;3], fun elem1 -> )
    bind( [10;11;12], fun elem2 ->
        elem1 + elem2
    ))
```

しかし、重要なことを見逃しています。 bind`に渡される継続関数は特定のシグネチャを持つことが要求されます。この関数はラップされていない型を受け取りますが、 *ラップされた* 型を生成します。

言い換えれば、継続関数はその結果として、*常に新しいリスト*を作成しなければならないのです。

```fsharp
bind( [1;2;3], fun elem -> // 単一の要素を使った式で、リストを返す )
```

そして，連鎖の例は，`elem1 + elem2` の結果をリストにして，次のように書く必要があります．

```fsharp
let add =
    bind( [1;2;3], fun elem1 ->
    bind( [10;11;12], fun elem2 ->
        [elem1 + elem2] // リストだ!
    ))
```

つまり、bindメソッドのロジックは次のようになります。

```fsharp
let bind(list,f) =
    // 1) リストの各要素に対して，fを適用する。
    // 2) f はリストを返します（シグネチャで要求されています）．
    // 3) 結果は，リストのリストです．
```

ここでもう一つ問題があります。Bind` 自身はラップされた型を生成しなければなりません。つまり、「リストのリスト」はダメだということです。これを単純な「1レベル」のリストに戻さなければなりません。

しかし、それは簡単で、`concat`というリストモジュールの関数があります。

これをまとめると、次のようになります。

```fsharp
let bind(list,f) =
    リスト
    |> リスト.マップ f
    |> リスト.コンカト

let add =
    bind( [1;2;3], fun elem1 ->
    bind( [10;11;12], fun elem2 ->
// elem1 + elem2 // エラー。
        [elem1 + elem2] // 正しくはリストを返します。
    ))
```

これで、`bind`が単体でどのように動作するかがわかったので、「リストのワークフロー」を作ることができます。

* `Bind` は、渡されたリストの各要素に継続関数を適用し、その結果得られるリストを1階層のリストにフラット化します。`List.collect` はまさにそれを行うライブラリ関数です。
* `Return` は unwrapped から wrapped への変換です。この場合、リストの単一の要素をラップすることを意味します。

```fsharp
タイプ ListWorkflowBuilder() =

    メンバー this.Bind(list, f) =
        リスト |> リスト.コレクト f

    メンバー this.Return(x) =
        [x]

let listWorkflow = new ListWorkflowBuilder()
```

ここでは、使用しているワークフローを紹介します。

```fsharp
let add =
    リストワークフロー {
        let! i = [1;2;3].
        let! j = [10;11;12]とします。
        リターン i+j
        }
printfn "added=%A" added

let multiplied =
    リストワークフロー {
        i = [1;2;3] とします。
        let! j = [10;11;12] とします。
        リターン i*j
        }
printfn "multiplied=%A" multiplied
```

そして、結果は、最初のコレクションのすべての要素が、2番目のコレクションのすべての要素と結合されたことを示しています。

```fsharp
val added : int list = [11; 12; 13; 12; 13; 14; 13; 14; 15].
val multiplied : int list = [10; 11; 12; 20; 22; 24; 30; 33; 36].
```

これは本当にすごいことです。 リストを列挙するロジックを完全に隠し、ワークフローだけを残しています。

### "for "のシンタックスシュガー

リストやシーケンスを特殊なケースとして扱うと、 `let!` をもう少し自然なものに置き換えるための素敵な構文シュガーを追加することができます。

具体的には、`let!` を `for...in...do` 式に置き換えることができます。

```fsharp
// letバージョン
let! i = [1;2;3] in [some expression].

// for...in...do バージョン
for i in [1;2;3] do [some expression].
```

どちらのバージョンも意味は全く同じで、見た目が違うだけです。

F#コンパイラがこれを実行できるようにするには、ビルダークラスに`For`メソッドを追加する必要があります。これは通常の `Bind` メソッドと全く同じ実装ですが、シーケンス型を受け取ることが必要です。

```fsharp
タイプ ListWorkflowBuilder() =

    メンバー this.Bind(list, f) =
        リスト |> リスト.コレクト f

    メンバー this.Return(x) =
        [x]

    メンバー this.For(list, f) =
        this.Bind(list, f)

let listWorkflow = new ListWorkflowBuilder()
```

そして、これをどのように使うかというと

```fsharp
let multiplied =
    リストワークフロー {
        for i in [1;2;3] do
        for j in [10;11;12] do
        リターン i*j
        }
printfn "multiplied=%A" multiplied
```

### LINQと "リストワークフロー"

for element in collection do`に見覚えはありませんか？これは、LINQで使われている「from element in collection ...`」の構文に非常に近いものです。
実際、LINQは基本的に同じ手法で、「from element in collection ...`」のようなクエリ式の構文から、舞台裏で実際のメソッド呼び出しに変換しています。

F#では、先ほど見たように、`bind`は`List.collect`関数を使用しています。LINQで`List.collect`に相当するのは`SelectMany`という拡張メソッドです。
そして、`SelectMany`がどのように動作するかを理解すれば、同じ種類のクエリを自分で実装することができます。 Jon Skeetはこれを説明する[役に立つブログ記事](http://codeblog.jonskeet.uk/2010/12/27/reimplementing-linq-to-objects-part-9-selectmany/)を書きました。

## IDの "ラッパータイプ"

この記事では、いくつかのラッパータイプを見てきました。そして、*すべての*コンピュテーション式には*必ず*関連するラッパータイプが必要であると述べてきました。

しかし、前の記事にあったloggingの例はどうでしょうか？そこにはラッパー・タイプはありませんでした。 裏で何かをする `let!` がありましたが、入力の型は出力の型と同じでした。型は変更されないままでした。

これに対する短い答えは、どんな型でもそれ自身の「ラッパー」として扱うことができるということです。 しかし、これを理解するには、もうひとつの深い方法があります。

一歩下がって、`List<T>`のようなラッパー型の定義が実際に何を意味するのかを考えてみましょう。

`List<T>`のような型があったとしても、それは実際には「本当の」型ではありません。`List<int>`は実在の型ですし、`List<string>`も実在の型です。しかし、`List<T>`はそれだけでは不完全です。実在の型になるために必要なパラメータがないのです。

`List<T>`を考える一つの方法は、それが型ではなく、*関数*であるということです。 これは、通常の値の具体的な世界ではなく、型の抽象的な世界での関数ですが、他の関数と同様に、値を他の値にマッピングします。ただし、この場合、入力値は型（例えば、`int`や`string`）であり、出力値は他の型（`List<int>`や`List<string>`）です。そして、他の関数と同様にパラメータを受け取りますが、この場合は「型パラメータ」を受け取ります。 これが、.NET開発者が「ジェネリック」と呼んでいる概念が、コンピュータサイエンスの用語では「[parametric polymorphism](http://en.wikipedia.org/wiki/Parametric_polymorphism)」と呼ばれている理由です。

他の型からある型を生成する関数（「型コンストラクタ」と呼ばれる）の概念を理解すれば、「ラッパー型」の本当の意味は、単なる型コンストラクタであることがわかります。

しかし、「ラッパータイプ」がある型を別の型にマッピングする関数であるならば、ある型を同じ型にマッピングする関数もこのカテゴリーに入るのではないでしょうか？確かにそうですね。型の「同一性」関数はこの定義に当てはまり、コンピュテーション式のラッパー型として使うことができます。

実際のコードに戻ると、ワークフロービルダーの最も単純な実装として、「IDワークフロー」を定義することができます。

```fsharp
タイプ IdentityBuilder() =
    メンバー this.Bind(m, f) = f m
    メンバー this.Return(x) = x
    メンバー this.ReturnFrom(x) = x

let identity = new IdentityBuilder()

let result = identity {.
    let! x = 1
    let！y = 2
    リターン x + y
    }
```

このように、先ほどのロギングの例は、IDのワークフローにロギングを追加しただけのものであることがわかります。

## まとめ

またしても長い記事になってしまい、たくさんのトピックを取り上げてしまいましたが、ラッパー・タイプの役割がより明確になったことを願っています。このシリーズの後半で、「ライター・ワークフロー」や「ステート・ワークフロー」などの一般的なワークフローを見ていく際に、ラッパー・タイプが実際にどのように使われるかを見ていきましょう。

この記事で取り上げたポイントをまとめてみました。

* コンピュテーション式の主な用途は、ある種のラッパー型に格納されている値をアンラップしたりリラップしたりすることです。
コンピュテーション式の主な用途は、ある種のラッパー型に格納されている値をアンラップおよびリラップすることです。 * 「Return」の出力を「Bind」の入力に与えることができるため、コンピュテーション式を簡単に構成することができます。
* すべてのコンピュテーション式には、必ず関連するラッパー型が必要です。
* 一般的なパラメータを持つ型であれば、リストであってもラッパー型として使用することができます。
* ワークフローを作成する際には、実装がラッピング、アンラッピング、コンポジションに関する3つの常識的なルールに準拠していることを確認する必要があります。


