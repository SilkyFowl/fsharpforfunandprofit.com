---
layout: post
title: "Defining functions"
description: "Lambdas and more"
date: 2012-05-08
nav: thinking-functionally
seriesId: "Thinking functionally"
seriesOrder: 8
categories: [Functions, Combinators]
---


「let」 構文を使用する標準的な関数の作成方法は、次のとおりです:

```fsharp
let add x y = x + y
```

このセクションでは、関数を作成する他の方法と、関数を定義するためのヒントを見てみましょう。

## 匿名関数(別名:ラムダ) ##

他の言語のラムダに慣れていれば、目新しいことではありません。匿名関数 (または 「ラムダ式」 ) は、次の形式で定義されます。

```fsharp
fun parameter1 parameter2 etc -> expression
```

C#でラムダを使うことに慣れているなら、次のような違いがあります。

* ラムダは特別なキーワード`fun`を持たなければなりません。これはC#版では必要ありません。
* 矢印記号は一重矢印`->`であり、C#の二重矢印 (`=>`) ではありません。

以下は、加算を定義するラムダです:

```fsharp
let add = fun x y -> x + y
```

これは従来の関数定義とまったく同じです。

```fsharp
let add x y = x + y
```

ラムダは、式が短く、その式のためだけに関数を定義したくない場合によく使われます。これまで見てきたように、リスト操作で特によく見られます。

```fsharp
// 個別に定義された関数
let add1 i = i + 1
[1..10] |> List.map add1

// 個別に定義せずにインライン化
[1..10] |> List.map (fun i -> i + 1)
```

ラムダを括弧で囲む必要があることに注意してください。

また、別の関数から関数を返すということを明確にするためにも使用されます。例えば、前述の 「`adderGenerator`」 関数もラムダで書き直すことができます。

```fsharp
// 元の定義
let adderGenerator x = (+) x

// ラムダを使った定義
let adderGenerator x = fun y -> x + y
```

ラムダ版は多少長くなっていますが、中間関数が返されることが明確になります。

ラムダを入れ子にすることもできます。ここでは、ラムダのみを使用した`adderGenerator`を定義する別の方法を示します:

```fsharp
let adderGenerator = fun x -> (fun y -> x + y)
```

次の3つの定義がすべて同じであると理解できますか?

```fsharp
let adderGenerator1 x y = x + y
let adderGenerator2 x   = fun y -> x + y
let adderGenerator3     = fun x -> (fun y -> x + y)
```

ピンとこなかったら、 [post on currying](/posts/currying/)を読み直してください。これは理解すべき重要なことです！

## 引数のパターンマッチング ##

関数を定義するときは、前述のように明示的にパラメータを渡すことができますが、パラメータセクションで直接パターンマッチチングを行うこともできます。つまり、パラメータセクションには、識別子だけでなく*patterns*を記述することができます。

次の例は、関数定義でパターンを使用する方法を示しています:

```fsharp
type Name = {first:string; last:string} // 新しい型を定義します
let bob = {first="bob"; last="smith"}   // 値を定義します

// 単一パラメータスタイル
let f1 name =                       // //単一のパラメータを指定します
   let {first=f; last=l} = name     // 関数本体の抽出
   printfn "first=%s; last=%s" f l

// パラメータ自体にマッチ
let f2 {first=f; last=l} =          // 直接パターンマッチング
   printfn "first=%s; last=%s" f l

// test
f1 bob
f2 bob
```

この種類のマッチングは、常にマッチングが可能な場合にのみ使用できます。たとえばユニオン型やリストは、一致しない場合があるためこの方法は使用できません。

```fsharp
let f3 (x::xs) =            // リストのパターンマッチングを使用する
   printfn "first element is=%A" x
```

不完全なパターン一致について警告が表示されます。


{{< linktarget "tuples" >}}。

## よくある間違い: タプル vs.複数パラメータ ##

C言語風の言語から来た場合、単一の関数パラメータとして使用されるタプルは、複数パラメータと驚くほどそっくりでしょう。これらはまったく違うものです！前述したようにカンマがある場合は、おそらくタプルの一部です。パラメータはスペース区切りです。

次に、この問題の例を示します。

```fsharp
// 2つの異なるパラメータを取る関数
let addTwoParams x y = x + y

// 単一のタプルを引数とする関数
let addTuple aTuple =
   let (x,y) = aTuple
   x + y

// 単一のタプルを引数とする別の関数
// しかし2つのintが必要なように見えます
let addConfusingTuple (x,y) = x + y
```

* 最初の定義「`addTwoParams`」 は、スペースで区切られた2つのパラメータを取ります。
* 2番目の定義「`addTube`」 は、単一のパラメータを取ります。次に、タプルの内部を「x」と「y」にバインドし、加算を行います。
* 3番目の定義「`addConfusingTuple'」は、「`addTuple'」と同様に単一のパラメータを取りますが、厄介なことに、このタプルはパターン・マッチングを使用してパラメータ定義の一部として展開され、束縛されています。実際のところ、これは 「`addTuple`」 とまったく同じです。

シグニチャを見てみましょう (よくわからない場合は、シグニチャを見ることをお勧めします) 。

```fsharp
val addTwoParams : int -> int -> int        // /2つのパラメータ
val addTuple : int * int -> int             // tuple->int
val addConfusingTuple : int * int -> int    // tuple->int
```

では、これらを使用しましょう:

```fsharp
//test
addTwoParams 1 2      // ok - 引数を区切るためにスペースが使われます。
addTwoParams (1,2)    // 単一のタプルを渡そうとしてエラーが発生しました
//   => error FS0001: この式に必要な型は'int'ですが、
//                    ここでは次の型が指定されています ''a * 'b'
```

ここでは、上記の2番目の場合にエラーが発生しています。

まず、コンパイラは`(1、2)`を` ('a*'b) `型の汎用タプルとして扱い、「`addTwoParams`」 の最初のパラメータとして渡そうとします。
次に、`addTwoParams`の最初のパラメータは`int`なのに、タプルを渡そうとしていると文句を言います。

タプルを作成するには、カンマを使用します。正しい方法は次のとおりです:

```fsharp
addTuple (1,2)           // ok
addConfusingTuple (1,2)  // ok

let x = (1,2)
addTuple x               // ok

let y = 1,2              // 必要なのはコンマ
                         // 括弧ではありません!
addTuple y               // ok
addConfusingTuple y      // ok
```

逆に、タプルを必要とする関数に複数パラメータを渡そうとすると、不明瞭なエラーが発生します。

```fsharp
addConfusingTuple 1 2    // 2つの引数を渡そうとしてエラーが発生しました
// => error FS0003: This value is not a function and
//                  cannot be applied
```

この場合、コンパイラは 「2つの引数を渡すので、`addConfusingTuple`はカリー化可能でなければならない」 と考えます。したがって、「`addConfusingTuple 1'」は、別の中間関数を返す部分適用と見なされます。この中間関数に 「2」 を適用しようとすると、中間関数はないのでエラーになります。パラメータの数が多すぎると発生する問題について話した記事でも、カリー化に関して全く同じエラーがありました。

### なぜタプルをパラメータとして使用しないのか? ###

上記のタプルに関する問題は、複数パラメータで関数を定義する別の方法があることを示唆しています。すなわち、パラメータを別々に渡すのではなく、全パラメータを単一の複合データ構造にまとめてしまうという方法です。次の例では、関数は単一のパラメータ (3つの項目を含むタプル) を引数に取ります。

```fsharp
let f (x,y,z) = x + y * z
// type is int * int * int -> int

// test
f (1,2,3)
```

関数シグネチャは、本来の3パラメータ関数とは異なることに注目してください。矢印は1つだけなのでパラメータは1つだけで、アスタリスクはこれが`(int*int*int) `のタプルであることを示します。

個々のパラメータではなく、タプルを使用するのはどのような場合でしょうか?

* タプル自体に意味がある場合。たとえば、3次元座標を操作している場合、3つの値からなるタプルの方が、3つの別々の値よりも適しています。
* タプルは、一緒に保管されるべきデータを一つの構造に束ねるために使用されることがあります。例えば、.NETライブラリの`TryParse`関数は、結果とブール値をタプルとして返します。 しかし、大量のデータを一括して保持している場合は、そのデータを格納するレコードやクラス型の定義が望ましいでしょう。

### 特殊なケース: タプルと.NETライブラリ関数 ###

カンマが多く見られるのは、.NETライブラリ関数を呼び出すときです！

いずれもタプルのような引数を取るので、これら関数の呼び出しはC#からの呼び出しと全く同じように見えます。

```fsharp
// correct
System.String.Compare("a","b")

// incorrect
System.String.Compare "a" "b"
```

その理由は、.NETライブラリー関数はカリー化されず、部分適用が不可能なためです。*常に全ての*パラメータを渡さなければならず、タプルの手法はこれを行うための簡単な方法です。

ただし、こうした呼び出しは一見タプルのように見えますが、実際には特別なケースもあることに注意してください。次のコードは、実際のタプルは使用できないため無効です。

```fsharp
let tuple = ("a","b")
System.String.Compare tuple   // error

System.String.Compare "a","b" // error
```

.NETライブラリー関数を部分適用したい場合は、 [前に見た](/posts/partial-application/)ように、以下の手順で.NETライブラリー関数のラッパー関数を書くのが一般的です。

```fsharp
// ラッパ関数を作成します
let strCompare x y = System.String.Compare(x,y)

// 部分適用
let strCompareWithB = strCompare "B"

// 高階関数で使用します
["A";"B";"C"]
|> List.map strCompareWithB
```

## 個別のパラメータとグループ化されたパラメータのガイドライン ##

タプルについての議論は、より一般的な話題につながります: どのような場合に関数パラメータを分離すべきか、またグループ化すのはどのような場合か?

この点で、F#はC#とは異なることに注意してください。C#で、*全ての*パラメータは*常に*与えられるので問題は発生しません！F#では,部分適用のために一部のパラメータしか指定されていない可能性があるため、グループ化が必要なパラメータと独立させるべきパラメータを区別する必要があります。

ここでは、独自の関数を設計する際、パラメータを構造化するための一般的なガイドラインを示します。

* 通常は、タプルやレコードなどの単一の構造ではなく、個別にパラメータを渡すことをお勧めします。これにより、部分適用のような柔軟な操作が可能になります。
* しかし、パラメータを一度に設定する*必要がある*場合、何らかのグループ化メカニズムを*使用してください*。

つまり、関数を設計するときは、「このパラメータを単独で指定できますだろう?」 と自問してください。答えが 「いいえ」 であれば、パラメータをグループ化する必要があります。

いくつかの例を見てみましょう。

```fsharp
// 2つの数字を渡して加算します。
// 2つの数字は独立しているので，2つのパラメータを使う
let add x y = x + y

// 地理的な座標として2つの数値を渡します。
// 数字は依存しているので，タプルまたはレコードにまとめます
let locateOnMap (xCoord,yCoord) = // do something

// 顧客のファーストネームとラストネームを設定します。
// 値は依存しているので、レコードにグループ化する
type CustomerName = {First:string; Last:string}となります。
let setCustomerName aCustomerName = // good
let setCustomerName first last = // 非推奨

// ファーストネームとラストネームを設定し、
// 認証情報も同様も渡します。
// 名前と認証情報は独立しています。別々にしてください。
let setCustomerName myCredentials aName = //good
```

最後に、部分適用のためにパラメータを適切に並べてください (前述の [投稿](/posts/partial-application/)のガイドラインを参照) 。たとえば、上に挙げた最後の関数で、なぜ`aName`パラメータの前に`myCredentials`パラメータを置いたのかを説明できますか?

## パラメータのない関数 ##

パラメータをまったく取らない関数が必要になることもあります。たとえば、何度も呼び出すことができる「hello world」関数が必要な場合があるとします。前節で見たように、この単純な定義はうまくいきません。

```fsharp
let sayHello = printfn "Hello World!"     // 目的のものではありません
```

この問題を解決するには関数にunitパラメータを追加するか、ラムダを使用します。

``fsharp
let sayHello() = printfn "Hello World!"           // good
let sayHello = fun () -> printfn "Hello World!"   // good
```

また、この関数は必ずunit引数を指定して呼び出す必要があります。

```fsharp
// call it
sayHello()
```

これは.NETライブラリではよくあることです。次に例を示します:

```fsharp
Console.ReadLine()
System.Environment.GetCommandLineArgs()
System.IO.Directory.GetCurrentDirectory()
```

忘れずにunitパラメータを付けて呼び出してください！

## 新しい演算子の定義 ##

1つまたは複数の演算子記号を使用した名前を持つ関数を定義できます (使用できる記号の正確なリストについては、 [F#documentation](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading) を参照してください) 。

```fsharp
// define
let (.*%) x y = x + y + 1
```

演算子を定義するときは、記号を括弧で囲む必要があります。

`*`で始まるカスタム演算子には、スペースが必要です、さもなくば、`(*`がコメントの始まりと解釈されます。

```fsharp
let ( *+* ) x y = x + y + 1
```

いったん定義すると、新しい関数は通常の方法でも使用できます、この場合も記号を括弧で囲みます。

```fsharp
let result = (.*%) 2 3
```

関数のパラメータが2つだけの場合は、括弧なしの中置演算子として使用できます。

```fsharp
let result = 2 .*% 3
```

また、`!`または`~`で始まる前置演算子を定義することもできます (いくつかの制限があります。 [F#documentation on operator overloading](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading#prefix-and-infix-operators) を参照してください) 。

```fsharp
let (~%%) (s:string) = s.ToCharArray()

//use
let result = %% "hello"
```

F#では、独自の演算子を作成することは非常に一般的であり、多くのライブラリは`>=>`や`<*>`などといった名前の演算子を出力しています。

## ポイントフリー・スタイル ##

関数の最後のパラメータを省略して乱雑さを減らす例はすでにたくさん見てきました。このスタイルは、**ポイントフリー・スタイル**または**暗黙型プログラミング**と呼ばれます。

次に例を示します:

```fsharp
let add x y = x + y   // 明示的
let add x = (+) x     // /ポイントフリー

let add1Times2 x = (x + 1) * 2    // 明示的
let add1Times2 = (+) 1 >> (*) 2   // ポイントフリー

let sum list = List.reduce (fun sum e -> sum+e) list // 明示的
let sum = List.reduce (+)                            // ポイントフリー
```

このスタイルには賛否両論があります。

長所は、下位のオブジェクトではなく、上位の関数構成に注目することです。例えば、「`(+) 1>> (*) 2`」 は明らかに加算演算の後に乗算が続くものです。また、「`List.reduce (+)`」 は、実際に適用されるリストを知る必要がなく、プラス演算が重要であることを明確にします。

ポイント・フリーは、根底にあるアルゴリズムを明確にし、コード間の類似性を明らかにするのに役立ちます--上記で使用された 「reduce」 関数がその良い例です--これについては、今後予定されているリスト操作の連載で説明します。

一方、ポイントフリーのスタイルばかりでは、コードが煩雑になる可能性があります。明示的なパラメータはドキュメントのような役割を果たします。パラメータ名 ("list"など) を見れば、その関数が何を対象にしているのか明確にわかります。

他のプログラミング手法と同様、最善のガイドラインは、最も明確な手法を用いることです。

## コンビネータ ##

「**コンビネータ**」 という言葉は、結果がパラメータのみに依存する関数を指すものです。つまり、外部の環境に依存しないということ、とりわけ他の関数やグローバル値にはまったくアクセスできない関数ということです。

このことは、コンビネータは様々な方法でパラメータを組み合わせる関数に限定されることを意味します。

既にいくつかのコンビネータを見てきました: 「pipe」 演算子と 「compose」 演算子です。定義を見ると、これらが行っていることは様々な方法でパラメータを並べ替えるだけであることは明らかです。

```fsharp
let (|>) x f = f x // 順方向パイプ
let (<|) f x = f x // 逆方向のパイプ
let (>>) f g x = g (f x) // 順方向の合成
let (<<) g f x = g (f x) // 逆方向の合成
```

一方、"printf "のような関数は、プリミティブではありますが、外界への依存（I/O）があるので、コンビネータではありません。

### コンビネータの鳥 ###

コンビネータは、コンピュータやプログラミング言語よりもずっと前に発明された論理 (いわゆる 「コンビネータ論理」 ) の全体の基礎です。コンビネータ論理は関数型プログラミングに非常に大きな影響を与えてきました。

コンビネータとコンビネータ論理についてさらに詳しく知りたい場合は、Raymond Smullyan氏の著書『To Mock a Mockingbird』をお勧めします。その中で、彼は他にも多くのコンビネータを記述し、それらに鳥の名前を気まぐれに付けています。ここでは、いくつかの一般的なコンビネータとその鳥の名前をいくつか紹介します。

```fsharp
let I x = x // 恒等関数、またはアホウドリ
let K x y = x // チョウゲンボウ(Kestrel)
let M x = x >> x // モッキンバード(Mockingbird)
let T x y = y x // ツグミ (これは見覚えがある!)
let Q x y z = y (x z) // クイナの鳥 (これも見覚えがある!)
let S x y z = x z (y z) // ムクドリ
// そして、悪名高き...
let rec Y f x = f (Y f) x // Yコンビナート、またはセイジの鳥
```

文字の名前は非常に標準的なものなので、「Kコンビネーター」と言えば、誰もがその用語を知っているでしょう。

多くの一般的なプログラミングパターンは、これらの標準的なコンビネーターを使って表現できることがわかりました。たとえば、チョウゲンボウは、何かをしてから元のオブジェクトを返すという、流暢なインターフェースによく見られるパターンです。Thrushはパイプ操作、Queer birdは前方合成、Y-combinatorは関数を再帰的にするために使われることで有名です。

実際、どんな計算可能な関数でも、チョウゲンボウとムクドリという2つの基本的なコンビネータだけで構築できるという有名な定理があります。

### コンビネータライブラリ ###

コンビネータライブラリは、連携するように設計された一連のコンビネータ関数を公開しているライブラリです。ライブラリの利用者はシンプルな関数を組み合わせることで、レゴを使って構築しているように、より大規模で複雑な関数を簡単に作ることができます。

よく設計されたコンバイネータ・ライブラリを使用すると、上位レベルの処理に集中し、下位レベルの 「ノイズ」 を後方へ押し出すことができます。これについては、 ["why use F#"](/series/why-use-fsharp.html) シリーズの例ですでに説明していますが、 `List`モジュールにはそうした機能が満載されています―考えてみれば、 「`fold`」 と 「`map`」 もコンビネータです。

コンビネータの別の利点は最も安全な型関数であるという点です。外部への依存がないため、グローバル環境が変化しても変化しません。グローバル値を読み取る関数、またはライブラリ機能を使用する関数は、コンテキストが異なる場合に呼出し間で割り込みや変更が発生する可能性があります。これはコンビネータでは起こり得ません。

F#では、構文解析 (FParsecライブラリ) 、HTML構築、テストフレームワークなどでコンビネータライブラリを利用できます。コンビネータについては、後のシリーズでさらに詳しく説明し、その使用方法を説明します。

## 再帰的な関数 ##

しばしば、関数はその内部で自身を参照することが必要になります。典型的な例はFibonacci関数です:

```fsharp
let fib i =
   match i with
   | 1 -> 1
   | 2 -> 1
   | n -> fib(n-1) + fib(n-2)
```

残念ながら、これはコンパイルできません。

	error FS0039: The value or constructor 'fib' is not defined

コンパイラにrecキーワードを使って再帰関数であることを伝える必要があります。

```fsharp
let rec fib i =
   match i with
   | 1 -> 1
   | 2 -> 1
   | n -> fib(n-1) + fib(n-2)
```

再帰的な関数やデータ構造は、関数型プログラミングでは非常によく使われるもので、後のシリーズでもこの話題を取り上げたいと思っています。
