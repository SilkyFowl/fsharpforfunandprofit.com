---
layout: post
title: "Against Railway-Oriented Programming"
description: "(when used thoughtlessly)"
date: 2019-12-20
categories: []
---

> この投稿は[2019 F# Advent Calendar](https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/)の一部です。
> そこにある他のすべての素晴らしい投稿をチェックしてください! そして、これを企画してくれたSergey Tihonさんに感謝します。

6年半前、私は["Railway Oriented Programming"](https://fsharpforfunandprofit.com/rop/)と呼ばれるものについて記事を書き、講演を行いました。これは、エラーを発生させる関数を連鎖させるために、`Result`/`Either`をどのように使うかを自分や他の人に説明するためのものでした。

驚いたことに、このくだらない鉄道の例えは本当に流行りました。今では、[Ruby](https://www.morozov.is/2018/05/27/do-notation-ruby.html)、[Java](https://github.com/StefanMacke/ao-railway)、[JavaScript](https://dorp.io/posts/railway-oriented-programming/)、[Kotlin](https://proandroiddev.com/railway-oriented-programming-in-kotlin-f1bceed399e5?gi=ce6e3bd2f69)など、あらゆる種類の言語で鉄道指向のプログラミングライブラリや投稿があります。
[Python](https://github.com/rob-earwaker/rail)などです。

今でも良い例えだとは思いますが、特に自分のツールボックスに追加したばかりのピカピカの新しいテクニックであれば、[よく軽率に使われる](https://twitter.com/scottwlaschin/status/997009818329198592)と思います。

そこで、この記事では、鉄道指向プログラミングを使用するべきではない理由を説明します。もっと正確に言うと、`Result`型をどこでも使ってはいけない理由です（なぜなら、ROPは`Result`型を返す関数を接続するための配管に過ぎないからです）。また、[Microsoft page on error management](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#error-management)にも、[this blog post](https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/)と同様に良いアドバイスがあります。

## #1 -- 診断が必要な場合はResultを使わないでください

エラーの場所やスタックトレース、その他の診断が必要な場合は、`Result`を使用しないでください。特に、例外の代わりに `Result` を使用して、スタックトレースや例外全体を `Result` の中に格納してはいけません。これでは意味がありません。

代わりに、`Result` を追加情報を持つ立派なブール値と考えてください。これは想定内の制御フローのためのもので、想定外の状況のためのものではありません。

## #2 -- Resultを使って例外を再発明してはいけない

例外で処理したほうがいいものも含めて、あらゆる種類のエラー処理に無差別に `Result` を使っている人を見たことがあります。"Try-catch "を再発明しないでください。

また、例外を完全に隠そうとしている人も見かけます。これは無意味です。どんなに多くの例外をResult」に変換しても、一部は必ず漏れてしまいます。システムの最上位部分で例外を適切に処理する必要があります。

## #3 -- 早く失敗する必要がある場合はResultを使わない

何か問題が発生して続行できなくなった場合、`Result`を返して続行するのはやめましょう。代わりに例外を発生させるか、あるいは[アプリを直ちに終了](https://docs.microsoft.com/en-us/dotnet/api/system.environment.failfast)するようにしましょう。

## #4 -- 誰も見ないならResultは使わない

複雑な制御フローを行っていても、そのロジックが外部から見えない場合は、ただ目的のために `Result` を使用しないでください。多くの場合、ローカルで例外を使用したほうがすっきりします。

例えば、ツリーをトラバースして情報を収集しているときに、何か問題が発生したときには早期に終了する必要があるとします。

ROPのアプローチでは、ノード処理関数に`Result`を返させて、それを`bind`を使って次のノード処理関数に渡す、というようなことをしています。複雑なナビゲーションの場合、コードがコンパイルされるようにロジックを組み立てるのに多くの時間を費やすことになります([Haskellプログラマはもちろん除外](https://hackage.haskell.org/package/recursion-schemes))。

一方で、プライベートなローカル例外を定義して（例えばPythonの`StopIteration`のようなスタイルで）、反復を命令的に書き、早く戻る必要があるときに例外を投げ、トップレベルでその例外をキャッチすることもできます。コードが長すぎず、例外がローカルに定義されている限り、このアプローチはしばしばコードをより明確にします。また、消費者が内部を見ることがなければ、害もなければ反則もないでしょう。

他の例としては、マイクロサービスを定義する場合があります。コード全体の長さが数百行程度で、呼び出し側には不透明な場合、サービスの境界を越えない限り、`Result`ではなく例外を使用しても全く問題ありません。

## #5 -- 誰もエラーケースを気にしない場合は Result を使わないこと

一般的に、`Result`は、エラーケースが、うまくいかないすべてのことの差別化された結合であると定義されます。

例えば、ファイルからテキストを読み取るために、次のような関数を定義します。

```fs
type ReadTextFromFile = FileInfo -> Result<string, FileError>
```

ここで、`FileError` は次のように定義されます。

```fs
type FileError =
  | FileNotFound
  | DirectoryNotFound
  | FileNotAccessible
  | PathTooLong
  | OtherIOError of string
```

しかし、この関数の消費者は、ファイルの読み込みに失敗する可能性のあるあらゆることを本当に気にするでしょうか？
おそらく彼らはテキストが欲しいだけで、なぜうまくいかなかったのかは気にしていないでしょう。その場合は、次のように、代わりに `option` を返す方が簡単かもしれません。

```fs
type ReadTextFromFile = FileInfo -> string option
```

`Result` はドメインモデリングのためのツールなので、ドメインモデルが必要としない場合は使用しないでください。

同様の例は、イベントソーシングを実装する際に見られ、標準的なシグネチャを持つ[コマンド処理関数](https://medium.com/@dzoukr/event-sourcing-step-by-step-in-f-be808aa0ca18)に見られます。

```fs
'state -> 'command -> 'event list
```

コマンドを実行する際に何か問題が発生した場合、実際には戻り値（コマンドによって作成されたイベントのリスト）にどのような影響があるのでしょうか。もちろん、エラーを処理してログを取る必要はありますが、実際に関数自体から`Result`を返す必要があるのでしょうか？あまりメリットがないのに、コードが複雑になってしまうのではないでしょうか。

## #6 -- I/OエラーにResultを使うときは注意が必要

ファイルを開こうとしてエラーが発生した場合、それを `Result` で囲むべきでしょうか？それは、あなたのドメインによります。
もしあなたがワープロを書いているのであれば、ファイルを開くことができないことは想定内であり、適切に処理されるべきです。一方で、アプリが依存している設定ファイルを開けない場合は、`Result`を返すべきではなく、速やかに失敗するべきです。

I/Oがある場所では、うまくいかないことがたくさんあります。すべての可能性を `Result` でモデル化しようとするのは魅力的ですが、これには強い忠告があります。代わりに、自分のドメインに必要な最低限のものだけをモデル化して、他のすべてのエラーを例外にしてください。

もちろん、ベストプラクティスに則り、I/Oを純粋なビジネスロジックから分離しているのであれば、コアコードで例外を扱う必要はほとんどないはずです。

## #7 -- パフォーマンスを気にするなら、Resultは使うな

これは絶対的な禁止事項というよりも、「注意してください」という意味合いが強いです。パフォーマンスを気にするコードがあることを前もって知っているのであれば、そこで `Result` を使用することに注意してください。実際、他の組み込み型（例：`List`）にも注意したほうがいいでしょう。しかし、いつものように、間違った最適化をしないように、事前に推測するのではなく、ホットスポットを見つけるようにしてください。

## #8 -- 相互運用性を重視するなら Result は使うな

ほとんどの OO 言語は `Result` やその他の差別化されたユニオンを理解していません。APIから失敗の可能性があるものを返す必要がある場合は、呼び出し側にとってより自然なアプローチを検討してください。たまには null を使ってみるのもいいかもしれません。あなたのAPIを呼び出すために、呼び出し側に関数型イディオムのエキスパートになることを強要しないでください。


## 使わない理由のまとめ 結果

* **Diagnostics**: スタックトレースやエラーの場所を気にする場合は、`Result`を使用しないでください。
* **Try/catchの再発明**: 既に組み込まれている言語ツールを使ってみませんか?
* **Fail fast**: ワークフローの最後で例外が発生する場合は、ワークフロー内で `Result` を使用しないでください。
* **制御フローのローカル例外はOK**: コントロールフローが複雑でプライベートなものであれば、コントロールフローに例外を使っても構いません。
* **Apathy**: 誰もエラーを気にしないのであれば、`Result`を返してはいけません。
* **I/O**: I/O**：ありとあらゆるI/OエラーをResultでモデル化しようとしないでください。
* **Performance**: パフォーマンスを気にするのであれば パフォーマンスを重視する場合は、`Result`の使用に注意してください。
* **Interop**: 相互運用性を重視する場合は、`Result` が何であるか、どのように動作するかを呼び出し側に理解させる必要はありません。

## どんなときにResultを使うのか？

では、このような否定的な意見が出た後、どのような場面で `Result` を使うべきなのでしょうか？

拙著[*Domain Modeling Made Functional*](/books/)でも述べましたが、私はエラーを3つのクラスに分類したいと考えています。

* **ドメイン・エラー**. これは、ビジネスプロセスの一部として予想されるエラーで、ドメインの設計に含まれていなければなりません。例えば、請求書で拒否された注文や、無効な製品コードを含む注文などがこれにあたります。ビジネスでは、このような事態に対処するための手順がすでに用意されているので、コードにはこれらのプロセスを反映させる必要があります。ドメインエラーは、他のものと同様にドメインの一部であり、ドメインモデリングに組み込まれ、ドメインの専門家と議論し、
可能であれば、型システムで文書化する必要があります。診断は必要ないことに注意してください。
* **Panics**. これはシステムを未知の状態にしてしまうエラーで、処理不可能なシステムエラー (例: "out of memory") やプログラマの過失によるエラー (例: "divide by zero" や "null reference") などがあります。パニックが発生した場合は、ワークフローを中断して例外を発生させ、その例外をキャッチして最も適切なレベル（アプリケーションのメイン関数など）でログに記録するのが最善の方法です。
* **インフラストラクチャーエラー**. これは、アーキテクチャの一部として予想されるエラーですが、ビジネスプロセスの一部ではなく、ドメインにも含まれません。例えば、ネットワークのタイムアウトや認証の失敗などがあります。これらの処理をドメインの一部としてモデル化すべき場合もあれば、パニックとして扱うこともできる。疑問がある場合は、ドメインの専門家に聞いてください。

そこで、上記の定義を使用します。

* `Result` は、期待される戻り値を文書化するために、ドメインモデリングプロセスの一部としてのみ使用されるべきです。そして、コンパイル時に、想定されるすべてのエラーケースを確実に処理します。
* ライブラリなどのマイクロドメインでも、必要に応じて `Result` を使用することができます。

結論としては、`Result`型や鉄道指向プログラミングは、適切に使えば非常に便利ですが、その使用例は思ったよりも限られており、かっこいいから、面白いからといって、あらゆるところで使うべきではないと思います。

お読みいただきありがとうございました。もっとF#の記事に興味がある方は、[2019 F# Advent Calendar](https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/)の続きをご覧ください。

{{< book_page_ddd_img >}}
