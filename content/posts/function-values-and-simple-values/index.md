---
layout: post
title: "Function Values and Simple Values"
description: "Binding not assignment"
date: 2012-05-03
nav: thinking-functionally
seriesId: "Thinking functionally"
seriesOrder: 3
---

シンプルな関数をもう一度見てみましょう。

```fsharp
let add1 x = x + 1
```

ここで，「x」は何を意味しているのでしょうか？それは次のような意味です。

1. 入力域から何らかの値を受け入れる。
2. その値を表すために "x"という名前を使い、後でそれを参照できるようにする。

このように、名前を使って値を表現することを「束縛(binding)」といいます。名前 "x "は入力値に "バインド "されています。

つまり、5という入力値でこの関数を評価すると、元の定義では「x」となっていたところが、「5」に置き換えられるということになります。

```fsharp
let add1 x = x + 1
add1 5
// "x"を "5 に置き換える
// add1 5 = 5 + 1 = 6
// 結果は6
```

これは代入ではないことを理解することが重要です。「x」は、値に割り当てられる「スロット」または変数ではなく、後で別の値に割り当てられます。これは名前 「x」 と値の1回限りの関連付けです。値は定義済みの整数の1つであり、変更できません。したがって、いったん束縛されると、xも変化することができません。;一度値に関連付けられると、常にある値に関連付けられます。

この概念は関数的思考の重要な部分である: 【*「変数」は存在しない、値だけが存在する*】です。

## 関数の値 ##

もう少し考えてみると、「`add1`」という名前自体が、「入力に1を加える関数」へのバインディングに過ぎないことがわかります。関数自体は、結合された名前とは無関係です。

`let add 1 x=x+1`と入力すると、F#コンパイラに「`add1`という名前が表示されるたびに、入力に1を追加する関数で置き換えるように」 指示することになります。「`add1`」は**関数値**.と呼ばれます。

関数がその名前から独立していることは、次のようにして確認してください:

```fsharp
let add1 x = x + 1
let plus1 = add1
add1 5
plus1 5
```

「`add1`」と「`plus1`」 は、同じ関数を参照する( 束縛された)2つの名前であることがわかります。

シグネチャは標準形式`定義域 -> 値域`であるため、関数値はいつでも特定できます。一般的な関数値シグネチャは次のとおりです。

```fsharp
val 関数名 : 定義域 -> 値域
```

## 単純な値 ##

常に整数5を返す、入力のない演算を想像してください。

![](./Functions_Const.png)

これは「定数」 演算です。

これをF#で書くにはどうすればいいですか?F#コンパイラに「`c`という名前が表示されるたびに、5に置き換えるように」と指示したいのです。方法は次のとおりです。

```fsharp
let c = 5
```

これが評価されると、次の値が返されます。

```fsharp
val c : int = 5
```

今回はマッピング矢印はなく、ただ1つのintです。新しいのは、後に実際の値が表示される等号です。F#コンパイラは、このバインディングが常に返す既知の値、すなわち値5を持っていることを認識します。

つまり定数、F#用語でいうと単純な値を定義したところです。

すべての単純な値には次のようなシグネチャがあるため、常に単純な値と関数値を区別できます。

```fsharp
val aName: type = constant    //矢印がないことに注意
```

## 単純な値 vs. 関数値 ##

C#などの言語とは異なり、F#では単純な値と関数値の間にほとんど違いがないことを理解することが重要です。いずれも名前にバインドして (同じキーワード`let`を使用して) 渡すことができる値です。実際、関数的思考の重要な側面の1つがまさにそれです。*関数は、別の関数への入力値として渡すことができる値である*、これについては後ほど説明します。

単純な値と関数値にはちょっとした違いがあることに注意してください。関数は常に定義域と値域を持ち、結果を得るには引数を 「適用」 する必要があります。単純な値は、束縛後に評価する必要はありません。上記の例を使用して、5を返す「定数関数」を定義したい場合は、以下のようにします。。

```fsharp
let c = fun()->5
// または
let c() = 5
```

これらの関数のシグネチャは

```fsharp
val c : unit -> int
```

であり，代わりに

```fsharp
val c : int = 5
```

ユニット、関数の構文、無名関数については後述します。

## 「値」 vs. 「オブジェクト」 ##

F#のような関数型プログラミング言語では、ほとんどのものは「値」と呼ばれます。C#のようなオブジェクト指向言語では、ほとんどのものは「オブジェクト」と呼ばれます。では、「値」と「オブジェクト」の違いは何でしょうか?

前述のように、値は定義域の要素にすぎません。intの定義域、文字列の定義域、intを文字列に対応付ける関数の定義域などです。原則として、値は不変です。値には、関連付けられた動作はありません。

標準的な定義におけるオブジェクトとは、データ構造とそれに関連する動作 (メソッド) をカプセル化したものです。一般に、オブジェクトには状態があり (つまり、変更可能) 、内部状態を変更するすべての操作はオブジェクト自体によって提供されなければなりません ( 「ドット」 表記を使用) 。

F#では、プリミティブ値にもオブジェクトのような動作があります。たとえば、文字列の長さを取得するには、次のようにします。

```fsharp
"abc".Length
```

しかし、一般的には、F#の標準的な値に"object"を使用することは避け、真のクラスのインスタンスや、メンバーメソッドを公開している他の値を参照するために確保します。

## 値の命名 ##

値や関数の名前には標準的な命名規則が適用され、基本的にはアンダースコアを含む任意の英数字の文字列が使用されます。 ただし、いくつかの追加機能があります。

名前の最初の文字を除いて、どこにでもアポストロフィーを入れることができます。つまり

```fsharp
A'b'c     begin'  //  有効な名前
```

末尾の目盛は、値の「変化形」を示すためによく使用されます。

```fsharp
let f = x
let f' = derivative f
let f'' = derivative f'
```

または、既存のキーワードのバリエーションを定義します。

```fsharp
let if' b t f = if b then t else f
```

また，任意の文字列を二重のバックスティックで囲み，有効な識別子とすることもできます。

```fsharp
``this is a name``  ``123``    //有効な名前
```

二重バックスティックのトリックは時々使いたくなるかもしれません。

* キーワードと同じ識別子を使いたい場合

```fsharp
let ``begin`` = "begin"
```

* Cucumberのように、ビジネスルール、ユニットテスト、BDDスタイルの実行可能な仕様に自然言語を使おうとするとき。

```fsharp
let ``is first time customer?`` = true
let ``add gift to order`` = ()
if ``is first time customer?`` then ``add gift to order``

// Unit test
let [<Test>] ``When input is 2 then expect square is 4``=
   // code here

// BDD clause
let [<Given>] ``I have (.*) N products in my cart`` (n:int) =
   // code here
```

C#とは異なり、F#の命名規則では、他の.NET言語に触れるように設計されていない限り、関数や値は大文字ではなく小文字で始まります（`PascalCase`ではなく`camelCase`）。 ただし、型やモジュールは大文字を使います。
